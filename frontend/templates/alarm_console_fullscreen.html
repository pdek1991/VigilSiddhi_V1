<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VigilSiddhi Alarm Console</title>
    <link rel="icon" type="image/x-xicon" href="/media/logo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better visual impact and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            overflow-x: hidden; /* Prevent horizontal scrolling */
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Ensure body takes full viewport height */
            margin: 0; /* Reset default body margin */
            padding: 0; /* Reset default body padding */
        }

        .alarm-console-container {
            padding: 1.5rem;
            background-color: #2d3748;
            border-radius: 0.6rem;
            margin: 1rem auto;
            width: 95%; /* Adjust width for full screen */
            box-sizing: border-box;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex-grow: 1; /* Allow it to take available height */
            display: flex;
            flex-direction: column;
            overflow-x: auto;
        }

        .alarm-console-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .alarm-console-table th,
        .alarm-console-table td {
            padding: 0.75rem;
            border: 1px solid #4a5568; /* Darker border */
            text-align: left;
            font-size: 0.9rem;
        }

        .alarm-console-table th {
            background-color: #4a5568; /* Header background */
            font-weight: 700;
            color: #e2e8f0;
            white-space: nowrap; /* Prevent headers from wrapping */
        }

        .alarm-console-table td {
            background-color: #2d3748; /* Cell background */
            color: #cbd5e0;
        }

        /* Severity Colors for table rows/text if needed */
        .severity-critical { color: #ef4444; } /* Red-500 */
        .severity-major { color: #f97316; } /* Orange-500 */
        .severity-minor { color: #fbbf24; } /* Yellow-400 */
        .severity-warning { color: #3b82f6; } /* Blue-500 */
        .severity-info { color: #22c55e; } /* Green-500 */
        .severity-unknown { color: #6b7280; } /* Gray-500 */

        /* Message box styles */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            border-radius: 0.6rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 2rem;
            z-index: 1001;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            color: #e2e8f0;
            font-size: 1.1rem;
            max-width: 80%;
            text-align: center;
        }
        .message-box button {
            background-color: #63b3ed;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.4rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .message-box button:hover {
            background-color: #4299e1;
        }
        .message-box.show {
            display: flex;
        }

        @media (max-width: 768px) {
            .alarm-console-table th,
            .alarm-console-table td {
                padding: 0.6rem;
                font-size: 0.8rem;
            }
        }
        @media (max-width: 480px) {
            .alarm-console-table th,
            .alarm-console-table td {
                padding: 0.4rem;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="py-4">
        <header class="dashboard-header text-center text-3xl font-bold text-red-500 mb-6">
            VigilSiddhi Active Alarm Console
        </header>

        <div id="alarm-console" class="alarm-console-container">
            <h2 class="text-xl font-semibold text-center mb-4 text-red-400">All Active Alarms</h2>
            <div class="overflow-x-auto flex-grow">
                <table class="alarm-console-table">
                    <thead>
                        <tr>
                            <th>Device Name</th>
                            <th>IP Address</th>
                            <th>Message</th>
                            <th>Severity</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody id="alarm-console-table-body">
                        <tr><td colspan="5" class="text-center py-4">Loading active alarms...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <h3 id="messageBoxTitle" class="text-xl font-bold mb-2"></h3>
        <p id="messageBoxContent" class="text-md mb-4"></p>
        <button onclick="document.getElementById('messageBox').classList.remove('show')">OK</button>
    </div>

    <script>
        const WS_URL = "ws://127.0.0.1:8000"; // WebSocket Notifier URL
        let ws; // WebSocket instance

        // Global map to store active alarms for the console
        // key: unique alarm identifier (e.g., device_ip-message-severity)
        // value: latest alarm object
        let activeAlarms = new Map();
        let alarmConsoleUpdateTimer = null;
        const IMMEDIATE_UPDATE_DELAY = 100; // milliseconds for debouncing

        // Severity order for sorting
        const SEVERITY_ORDER = {
            'INFO': 0, 'OK': 0, 'NORMAL': 0,
            'WARNING': 1, 'MINOR': 1,
            'ALARM': 2, 'MAJOR': 2,
            'ERROR': 3, 'CRITICAL': 3, 'FATAL': 3,
            'UNKNOWN': -1
        };

        // Custom Message Box function
        function showMessageBox(title, message) {
            const msgBox = document.getElementById('messageBox');
            document.getElementById('messageBoxTitle').textContent = title;
            document.getElementById('messageBoxContent').textContent = message;
            msgBox.classList.add('show');
        }
        window.showMessageBox = showMessageBox; // Expose globally

        // --- WebSocket Logic ---
        function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                return; // Already connected or connecting
            }
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                console.log("WebSocket connected from Alarm Console!");
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                console.log("WebSocket message received in Alarm Console:", message);
                processWebSocketMessage(message);
            };

            ws.onclose = (event) => {
                console.warn("WebSocket disconnected from Alarm Console:", event.code, event.reason);
                // Attempt to reconnect after a delay
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (error) => {
                console.error("WebSocket error in Alarm Console:", error);
                ws.close(); // Close to trigger onclose and retry
            };
        }

        function processWebSocketMessage(message) {
            // Changed 'dest_name' to 'source_name' based on user feedback
            const { frontend_block_id, group_name, status, severity, message: msgText, source_name, polled_value, expected_value } = message;

            // Alarms are added to the console if their severity is not 'OK' or 'NORMAL'
            if (status && SEVERITY_ORDER[severity.toUpperCase()] > SEVERITY_ORDER['OK']) {
                const alarmEntry = {
                    device_name: message.device_name || message.group_name || 'N/A',
                    server_ip: message.ip || 'N/A', // Use 'ip' field from WS message
                    message: msgText || 'No message provided',
                    severity: severity || 'UNKNOWN',
                    timestamp: message.time || new Date().toISOString(), // Use 'time' field from WS message
                    frontend_block_id: frontend_block_id,
                    type: message.agent_type || 'websocket',
                    source_name: source_name || null // Store source_name
                };
                // Use a robust key for deduplication
                const alarmKey = `${alarmEntry.server_ip}-${alarmEntry.message}-${alarmEntry.severity}-${alarmEntry.frontend_block_id || ''}`;
                
                if (!activeAlarms.has(alarmKey) || new Date(alarmEntry.timestamp) > new Date(activeAlarms.get(alarmKey).timestamp)) {
                    activeAlarms.set(alarmKey, alarmEntry);
                }
                triggerImmediateAlarmConsoleUpdate(); // Debounced update
            } else if (status && SEVERITY_ORDER[severity.toUpperCase()] <= SEVERITY_ORDER['OK']) {
                // If status becomes OK, attempt to clear related alarms from console
                clearAlarmsForBlock(frontend_block_id);
            }
        }

        function clearAlarmsForBlock(frontendBlockId) {
            if (!frontendBlockId) return;
            const keysToDelete = [];
            activeAlarms.forEach((alarm, key) => {
                if (alarm.frontend_block_id === frontendBlockId) {
                    keysToDelete.push(key);
                }
            });
            keysToDelete.forEach(key => activeAlarms.delete(key));
            if (keysToDelete.length > 0) {
                triggerImmediateAlarmConsoleUpdate(); // Re-render if alarms were cleared
            }
        }

        function triggerImmediateAlarmConsoleUpdate() {
            clearTimeout(alarmConsoleUpdateTimer);
            alarmConsoleUpdateTimer = setTimeout(() => {
                const alarmsToDisplay = Array.from(activeAlarms.values());
                alarmsToDisplay.sort((a, b) => {
                    const timeDiff = new Date(b.timestamp) - new Date(a.timestamp);
                    if (timeDiff !== 0) return timeDiff;
                    return SEVERITY_ORDER[b.severity.toUpperCase()] - SEVERITY_ORDER[a.severity.toUpperCase()];
                });
                renderAlarmConsole(alarmsToDisplay);
            }, IMMEDIATE_UPDATE_DELAY);
        }

        // Function to fetch ALL active alarms from Flask backend (Elasticsearch) on page load
        async function fetchAllAlarmsFromBackend() {
            try {
                const response = await fetch('/api/v1/get_all_active_alarms');
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Failed to fetch all alarms from backend: ${response.status} - ${errorText}`);
                    return;
                }
                const data = await response.json();
                
                activeAlarms.clear(); // Clear existing and repopulate
                (data.alarms || []).forEach(alarm => {
                    const alarmKey = `${alarm.server_ip}-${alarm.message}-${alarm.severity}-${alarm.frontend_block_id || ''}`;
                    activeAlarms.set(alarmKey, alarm);
                });
                console.log(`Fetched ${activeAlarms.size} active alarms from backend for full console.`);
                triggerImmediateAlarmConsoleUpdate(); // Render after initial fetch
            } catch (error) {
                console.error("Error fetching all alarms from backend:", error);
            }
        }

        // Function to render the alarm console table
        function renderAlarmConsole(alarms) {
            const tableBody = document.getElementById('alarm-console-table-body');
            tableBody.innerHTML = ''; // Clear existing rows

            if (alarms.length === 0) {
                const noAlarmsRow = document.createElement('tr');
                noAlarmsRow.innerHTML = `<td colspan="5" class="text-center py-4">No active alarms found.</td>`;
                tableBody.appendChild(noAlarmsRow);
            } else {
                alarms.forEach(alarm => {
                    const row = document.createElement('tr');
                    let timeFormatted = alarm.timestamp;
                    try {
                        const date = new Date(alarm.timestamp);
                        timeFormatted = date.toLocaleString();
                    } catch (e) {
                        console.warn("Could not parse alarm timestamp:", alarm.timestamp, e);
                    }

                    // Determine CSS class for severity coloring based on predefined classes
                    const severityClass = `severity-${(alarm.severity || 'UNKNOWN').toLowerCase()}`;
                    
                    const deviceDisplayName = (alarm.channel_name && alarm.channel_name !== 'N/A' && alarm.device_name && alarm.device_name !== 'N/A')
                                                ? `${alarm.channel_name} - ${alarm.device_name}`
                                                : alarm.channel_name || alarm.device_name || alarm.server_ip || 'N/A';

                    row.innerHTML = `
                        <td class="${severityClass}">${deviceDisplayName}</td>
                        <td class="${severityClass}">${alarm.server_ip || 'N/A'}</td>
                        <td class="${severityClass}">${alarm.message || 'No Message'}</td>
                        <td class="${severityClass}">${alarm.severity || 'Unknown'}</td>
                        <td class="${severityClass}">${timeFormatted}</td>
                    `;
                    tableBody.appendChild(row);
                });
            }
        }

        // Initialize the console when the window loads
        window.onload = function() {
            // Retrieve alarms from sessionStorage if navigated from main dashboard
            const storedAlarms = sessionStorage.getItem('fullAlarmList');
            if (storedAlarms) {
                activeAlarms = new Map(JSON.parse(storedAlarms).map(alarm => {
                    // Re-create key for deduplication consistency
                    const key = `${alarm.server_ip}-${alarm.message}-${alarm.severity}-${alarm.frontend_block_id || ''}`;
                    return [key, alarm];
                }));
                renderAlarmConsole(Array.from(activeAlarms.values()));
                sessionStorage.removeItem('fullAlarmList'); // Clear it after use
            } else {
                fetchAllAlarmsFromBackend(); // If opened directly, fetch all active alarms from backend
            }
            connectWebSocket(); // Establish WebSocket connection
        };
    </script>
</body>
</html>
