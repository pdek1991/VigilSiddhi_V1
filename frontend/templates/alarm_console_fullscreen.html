<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Alarms</title>
    <!-- Favicon using GIF for broader compatibility and consistency -->
    <link rel="icon" type="image/gif" href="/static/logo.gif">
    <!-- Added .ico favicon for broader compatibility -->
    <link rel="icon" type="image/x-icon" href="/static/logo.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Lighter background */
            color: #333;
        }
        header {
            background-image: linear-gradient(to right, #0d0d0e, #212222); /* Subtle gradient */
            color: white;
            padding: 1rem 1.5rem; /* Padding for the header */
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 4px solid #4a5568;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            flex-wrap: wrap;
            gap: 1rem;
        }
        header .left {
            display: flex;
            align-items: center;
            /* Ensure logo area has enough height */
            min-height: 70px;
        }
        header img {
            max-height: 100%; /* Make logo fit the height of its parent (.left) */
            height: auto; /* Maintain aspect ratio */
            width: auto; /* Maintain aspect ratio */
            border-radius: 0; /* Removed circular shape */
            border: none; /* Removed border around logo */
            flex-shrink: 0;
            object-fit: contain; /* Ensures the entire image is visible within its bounds */
            padding: 0; /* Removed padding to let logo fill more space if needed */
        }
        header h1 {
            flex-grow: 1;
            font-size: 2.2rem;
            margin: 0;
            text-align: center;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }

        /* Summary cards now inside header, smaller and to the right */
        .summary-cards {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 0.75rem;
            margin-left: auto;
            flex-wrap: nowrap;
            padding: 0.5rem 0;
        }
        .card {
            border-radius: 9999px; /* Made summary blocks circular */
            padding: 0.6rem 0.9rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            text-align: center;
            min-width: 90px;
            max-width: 120px;
            aspect-ratio: 1 / 1; /* Make it a perfect circle */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out;
            cursor: pointer;
            color: #333;
        }
        .card:hover {
            transform: translateY(-3px);
        }
        .card-title {
            font-size: 0.7rem;
            font-weight: 500;
            color: #555;
            margin-bottom: 0.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .card-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #1a202c;
        }
        /* Card background colors matching row severity colors */
        .card.critical { background-color: #ffeaea; }
        .card.warning { background-color: #fffde7; }
        .card.info { background-color: #e6f7ff; }
        .card.total { background-color: #d4edda; }


        .filter-container {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background-color: #e2e8f0;
            justify-content: center;
            border-bottom: 1px solid #cbd5e0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            align-items: center;
        }
        .input-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: flex-end;
            width: 100%;
        }
        .action-buttons {
            display: flex;
            gap: 1rem; /* Gap between buttons */
            justify-content: center; /* Center the buttons */
            width: 100%; /* Take full width of container */
            margin-top: 1rem; /* Space from filters above */
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .filter-group label {
            font-size: 0.85rem;
            color: #4a5568;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        .filter-container input,
        .filter-container select {
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            border-radius: 0.375rem;
            border: 1px solid #cbd5e0;
            min-width: 160px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease-in-out;
            background-color: white;
        }
        .filter-container input:focus,
        .filter-container select:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }
        .filter-container button {
            padding: 0.75rem 1.25rem;
            font-size: 0.95rem;
            border-radius: 0.375rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .filter-container button.search-btn {
            background-color: #4299e1;
            color: white;
        }
        .filter-container button.search-btn:hover {
            background-color: #3182ce;
            transform: translateY(-1px);
        }
        .filter-container button.clear-btn {
            background-color: #e53e3e;
            color: white;
        }
        .filter-container button.clear-btn:hover {
            background-color: #c53030;
            transform: translateY(-1px);
        }

        table {
            width: 95%;
            border-collapse: collapse;
            margin: 1.5rem auto;
            background-color: white;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        th, td {
            border: 1px solid #e2e8f0;
            padding: 0.9rem 1rem;
            text-align: center;
            vertical-align: middle;
            position: relative;
        }
        th {
            background-color: #2d3748;
            color: white;
            font-weight: 600;
            white-space: nowrap;
        }
        td {
            font-size: 0.9rem;
            color: #4a5568;
        }
        tr:hover td {
            background-color: #f7fafc;
        }

        /* Severity based row coloring - applied to td with !important for higher specificity */
        tr.severity-Critical td {
            background-color: #ffeaea !important;
        }
        tr.severity-Warning td {
            background-color: #fffde7 !important;
        }
        tr.severity-Info td {
            background-color: #e6f7ff !important;
        }

        /* Resizer handle */
        .resizer {
            position: absolute;
            right: 0;
            top: 0;
            width: 5px;
            cursor: col-resize;
            z-index: 1;
            height: 100%;
            background: transparent;
        }
        .resizer:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Pagination controls */
        .pagination-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            background-color: #f8f8f8;
            border-top: 1px solid #e2e8f0;
            border-radius: 0 0 0.5rem 0.5rem;
            margin: -1.5rem auto 1.5rem auto;
            width: 95%;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);
        }
        .pagination-container button {
            background-color: #4299e1;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .pagination-container button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        .pagination-container button:hover:not(:disabled) {
            background-color: #3182ce;
        }
        .pagination-container span {
            font-size: 0.95rem;
            color: #4a5568;
        }
        .pagination-container .page-number {
            background-color: #edf2f7;
            color: #2d3748;
            padding: 0.5rem 0.8rem;
            border-radius: 0.375rem;
            font-weight: 600;
            min-width: 35px;
            text-align: center;
        }
        .pagination-container .page-number.active {
            background-color: #38a169;
            color: white;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .summary-cards {
                flex-direction: column;
                align-items: center;
                padding-bottom: 0.5rem;
                width: 100%;
                margin-left: 0;
                order: 3;
            }
            .card {
                width: 90%;
                max-width: none;
                margin-bottom: 0.5rem;
            }
            header {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            header h1 {
                order: 2;
            }
            header .left {
                order: 1;
            }

            .filter-container {
                flex-direction: column;
                align-items: stretch;
            }
            .input-filters, .action-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            .filter-group {
                width: 100%;
            }
            .filter-container input,
            .filter-container select,
            .filter-container button {
                min-width: unset;
                width: 100%;
            }
            table, thead, tbody, th, td, tr {
                display: block;
            }
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 0.625em;
                border-radius: 0.5rem;
                overflow: hidden;
            }
            td {
                border: none;
                border-bottom: 1px solid #e2e8f0;
                position: relative;
                padding-left: 50%;
                text-align: right;
            }
            td:before {
                position: absolute;
                top: 0.9rem;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
                font-weight: bold;
                text-align: left;
            }
            .pagination-container {
                flex-direction: column;
                gap: 0.5rem;
            }
            .pagination-container button, .pagination-container span {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="left">
            <!-- Logo now uses GIF and fills available height without circular border -->
            <!-- Ensure that '/static/logo.gif' is the correct path where your web server serves the logo. -->
            <!-- If the logo is in the same folder as this HTML, use src="logo.gif". -->
            <img src="/static/logo.gif" alt="VigilSiddhi" onerror="this.onerror=null;this.src='https://placehold.co/80x80/63b3ed/ffffff?text=VigilSiddhi+Logo';">
        </div>
        <h1>Historical Alarms Overview</h1>
        <!-- Summary cards remain inside the header -->
        <div class="summary-cards" id="summary-cards">
            <!-- Summary cards will be rendered here by JavaScript -->
        </div>
    </header>

    <div class="filter-container">
        <div class="input-filters">
            <div class="filter-group">
                <label for="from_timestamp">From Timestamp</label>
                <input type="datetime-local" id="from_timestamp">
            </div>
            <div class="filter-group">
                <label for="to_timestamp">To Timestamp</label>
                <input type="datetime-local" id="to_timestamp">
            </div>
            <div class="filter-group">
                <label for="device_name">Device Name</label>
                <input list="device_names" type="text" id="device_name" placeholder="Search Device Name">
                <datalist id="device_names"></datalist>
            </div>
            <div class="filter-group">
                <label for="severity">Severity</label>
                <input list="severities" type="text" id="severity" placeholder="Search Severity">
                <datalist id="severities"></datalist>
            </div>
            <div class="filter-group">
                <label for="type">Type</label>
                <input list="types" type="text" id="type" placeholder="Search Type">
                <datalist id="types"></datalist>
            </div>
            <div class="filter-group">
                <label for="group_name">Group Name</label>
                <input list="group_names" type="text" id="group_name" placeholder="Search Group Name">
                <datalist id="group_names"></datalist>
            </div>
            <div class="filter-group">
                <label for="message">Message</label>
                <input type="text" id="message" placeholder="Search Message">
            </div>
            <!-- Block ID filter group - now hidden but present for functional use -->
            <div class="filter-group" style="display: none;">
                <label for="block_id_filter">Block ID</label>
                <input type="text" id="block_id_filter" placeholder="Filter by Block ID" disabled>
            </div>
        </div>
        <div class="action-buttons">
            <button class="search-btn" onclick="applyFiltersAndFetch()">Search</button>
            <button class="clear-btn" onclick="clearFilters()">Clear Filters</button>
        </div>
    </div>

    <table id="results">
        <thead>
            <tr>
                <th style="width: 150px;">Timestamp</th>
                <th style="width: 120px;">Device Name</th>
                <th style="width: 100px;">Type</th>
                <th style="width: 120px;">Device IP</th>
                <th style="width: 150px;">Group Name</th>
                <th style="width: 350px;">Message</th> <!-- Default larger width for message -->
                <th style="width: 100px;">Severity</th>
                <th style="width: 100px; display: none;">Block ID</th> <!-- Hiding the column header -->
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div class="pagination-container" id="pagination-controls">
        <!-- Pagination controls will be rendered here by JavaScript -->
    </div>

    <script>
        let allData = []; // Stores all fetched data
        let filteredData = []; // Stores data after filters are applied
        let currentPage = 1;
        const alarmsPerPage = 100;
        let currentResizableColumn = null;
        let startX, startWidth;
        const REFRESH_INTERVAL_MS = 60 * 1000; // 1 minute in milliseconds
        let autoRefreshInterval; // To store the interval ID for clearing

        /**
         * Parses URL query parameters.
         * @returns {Object} An object containing the query parameters.
         */
        function getQueryParams() {
            const params = {};
            window.location.search.substring(1).split('&').forEach(param => {
                const parts = param.split('=');
                if (parts.length === 2) {
                    params[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
                }
            });
            return params;
        }

        /**
         * Normalizes frontend_block_id (e.g., C.104 to C.0104) for consistency.
         * @param {string} blockId - The block ID to normalize.
         * @returns {string} The normalized block ID.
         */
        function normalizeFrontendBlockId(blockId) {
            if (!blockId || !blockId.startsWith('C.')) {
                return blockId;
            }
            const match = blockId.match(/^C\.(\d+)(\d{2})$/);
            if (match) {
                let channelNum = parseInt(match[1], 10);
                let deviceSuffix = match[2];
                const paddedChannelNum = String(channelNum).padStart(2, '0');
                return `C.${paddedChannelNum}${deviceSuffix}`;
            }
            return blockId;
        }

        /**
         * Sets the default 'From Timestamp' to 12 hours ago and 'To Timestamp' to now.
         */
        function setDefaultTimeFilters() {
            const now = new Date();
            const twelveHoursAgo = new Date(now.getTime() - (12 * 60 * 60 * 1000));

            // Format to 'YYYY-MM-DDTHH:MM' for datetime-local input
            const formatDateTimeLocal = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${year}-${month}-${day}T${hours}:${minutes}`;
            };

            document.getElementById('from_timestamp').value = formatDateTimeLocal(twelveHoursAgo);
            document.getElementById('to_timestamp').value = formatDateTimeLocal(now);
        }

        /**
         * Initializes column resizing functionality.
         * Adds resizer elements to table headers and sets up mouse event listeners.
         */
        function setupResizableColumns() {
            const headers = document.querySelectorAll('#results th');
            headers.forEach(header => {
                // Check if a resizer already exists to prevent duplicates on re-render if any
                if (!header.querySelector('.resizer')) {
                    const resizer = document.createElement('div');
                    resizer.classList.add('resizer');
                    header.appendChild(resizer);

                    resizer.addEventListener('mousedown', initResize);
                }
            });
        }

        /**
         * Initializes the resize operation when a resizer is moused down.
         * @param {MouseEvent} e - The mouse event.
         */
        function initResize(e) {
            currentResizableColumn = e.target.parentNode;
            startX = e.clientX;
            startWidth = currentResizableColumn.offsetWidth;
            document.addEventListener('mousemove', resizeColumn);
            document.addEventListener('mouseup', stopResize);
            document.body.style.cursor = 'col-resize'; // Change cursor while resizing
        }

        /**
         * Resizes the column based on mouse movement.
         * @param {MouseEvent} e - The mouse event.
         */
        function resizeColumn(e) {
            if (currentResizableColumn) {
                const newWidth = startWidth + (e.clientX - startX);
                // Ensure minimum width to prevent columns from collapsing too much
                currentResizableColumn.style.width = Math.max(50, newWidth) + 'px';
            }
        }

        /**
         * Stops the resize operation.
         */
        function stopResize() {
            currentResizableColumn = null;
            document.removeEventListener('mousemove', resizeColumn);
            document.removeEventListener('mouseup', stopResize);
            document.body.style.cursor = ''; // Reset cursor
        }

        /**
         * Fetches historical alarm data from the backend API.
         * Populates filters, renders summary cards, and renders the table upon successful fetch.
         * @param {boolean} applyCurrentFilters - If true, collect and apply current UI filter values (from inputs).
         * If false, only use time filters and initialBlockId.
         * @param {string} [initialBlockId] - An optional block ID to pre-filter by on initial load.
         */
        async function fetchData(applyCurrentFilters = false, initialBlockId = null) {
            try {
                const tbody = document.querySelector("#results tbody");
                tbody.innerHTML = '<tr><td colspan="8" class="text-center py-4 text-gray-500">Loading alarms...</td></tr>';
                document.getElementById('pagination-controls').innerHTML = ''; // Clear pagination on load
                
                const fetchBody = {};

                // Always include time filters
                const fromTimestamp = document.getElementById('from_timestamp').value;
                const toTimestamp = document.getElementById('to_timestamp').value;
                if (fromTimestamp) {
                    fetchBody.from_timestamp = new Date(fromTimestamp).toISOString();
                }
                if (toTimestamp) {
                    fetchBody.to_timestamp = new Date(toTimestamp).toISOString();
                }

                // If applyCurrentFilters is true, or initialBlockId is provided, get other filter values from UI
                // Note: initialBlockId is set into block_id_filter input first.
                if (applyCurrentFilters || initialBlockId) {
                    fetchBody.device_name = document.getElementById('device_name').value;
                    fetchBody.severity = document.getElementById('severity').value;
                    fetchBody.agent_type = document.getElementById('type').value; // Map 'type' input to 'agent_type' for backend
                    fetchBody.group_name = document.getElementById('group_name').value;
                    fetchBody.message = document.getElementById('message').value;
                    fetchBody.block_id = document.getElementById('block_id_filter').value; // Get from the hidden input
                }

                console.log("Sending fetchBody to backend:", fetchBody); // Debug log

                const response = await fetch("/api/v1/get_alarm_history", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(fetchBody)
                });

                const data = await response.json();
                if (data.error) {
                    console.error("API Error:", data.error);
                    showUserMessage(`❌ Failed to fetch data: ${data.error}. Check console for details.`);
                    return;
                }

                allData = data.hits; // The backend now returns { "hits": [...] }
                filteredData = allData; // The backend should have already filtered, so assign directly
                
                renderSummaryCards(filteredData); // Summary cards reflect the already filtered data
                currentPage = 1; // Reset to first page
                renderTable(filteredData); // Table reflects filtered data
                populateFilters(allData); // Populate datalists from ALL fetched data (for future filtering)
                setupResizableColumns();
            }
            catch (err) {
                console.error("Fetch Error:", err);
                showUserMessage("❌ Failed to fetch data. Check console for details.");
            }
        }

        /**
         * Renders summary cards with counts for total, critical, warning, and info alarms.
         * @param {Array<Object>} data - The alarm data to count.
         */
        function renderSummaryCards(data) {
            const summaryContainer = document.getElementById('summary-cards');
            const counts = {
                total: 0, // Initialize total count here
                critical: 0,
                warning: 0,
                info: 0
            };

            data.forEach(hit => {
                const s = hit._source;
                const sev = (s.severity || '').toLowerCase();
                if (["critical", "error"].includes(sev)) {
                    counts.critical++;
                } else if (["warning", "major", "minor"].includes(sev)) {
                    counts.warning++;
                } else {
                    counts.info++;
                }
                counts.total++; // Increment total for each item
            });

            summaryContainer.innerHTML = `
                <div class="card total" onclick="applySeverityFilter('')">
                    <div class="card-title">Total</div>
                    <div class="card-value">${counts.total}</div>
                </div>
                <div class="card critical" onclick="applySeverityFilter('critical')">
                    <div class="card-title">Critical</div>
                    <div class="card-value">${counts.critical}</div>
                </div>
                <div class="card warning" onclick="applySeverityFilter('warning')">
                    <div class="card-title">Warning</div>
                    <div class="card-value">${counts.warning}</div>
                </div>
                <div class="card info" onclick="applySeverityFilter('info')">
                    <div class="card-title">Info</div>
                    <div class="card-value">${counts.info}</div>
                </div>
            `;
        }

        /**
         * Helper function to apply a severity filter directly from summary cards.
         * @param {string} severityType - The severity type to filter by (e.g., 'critical', 'warning', 'info', or empty for all).
         */
        function applySeverityFilter(severityType) {
            // Clear other filters first
            document.getElementById('device_name').value = '';
            document.getElementById('severity').value = ''; // This will be set below
            document.getElementById('type').value = '';
            document.getElementById('group_name').value = '';
            document.getElementById('message').value = '';
            // Do NOT clear block_id_filter if it was set by URL, let it persist
            
            // Set the severity filter and trigger fetch
            document.getElementById('severity').value = severityType;
            applyFiltersAndFetch(); // Trigger a re-fetch with all current UI filters
        }

        /**
         * Function to be called when "Search" button is clicked.
         * It will fetch new data, applying all current UI filter values.
         */
        function applyFiltersAndFetch() {
            fetchData(true); // Pass true to indicate that all filters should be applied
        }

        /**
         * Internal function to apply filters to the currently loaded `allData`.
         * This function is now redundant for primary filtering since `fetchData` does it server-side.
         * It's kept for potential future client-side post-processing or fallback.
         */
        function _applyFiltersInternal() {
            // This function is effectively replaced by backend filtering in fetchData
            // However, if you wanted client-side *refinement* of already backend-filtered data,
            // this would be the place. For now, it's simplified.
            filteredData = allData.filter(hit => {
                const s = hit._source;
                const filters = { // Re-read filters for robustness, though mostly for client-side use if needed
                    device_name: document.getElementById('device_name').value.toLowerCase(),
                    severity: document.getElementById('severity').value.toLowerCase(),
                    type: document.getElementById('type').value.toLowerCase(), // This is UI 'type'
                    group_name: document.getElementById('group_name').value.toLowerCase(),
                    message: document.getElementById('message').value.toLowerCase(),
                    from_timestamp: document.getElementById('from_timestamp').value,
                    to_timestamp: document.getElementById('to_timestamp').value,
                    block_id: document.getElementById('block_id_filter').value
                };

                const timestamp = new Date(s.timestamp);
                const fromTime = filters.from_timestamp ? new Date(filters.from_timestamp) : null;
                const toTime = filters.to_timestamp ? new Date(filters.to_timestamp) : null;

                const matchesSeverity = (() => {
                    if (!filters.severity) return true;
                    const sev = (s.severity || '').toLowerCase();
                    if (filters.severity === 'critical') return ["critical", "error", "fatal"].includes(sev);
                    if (filters.severity === 'warning') return ["warning", "major", "minor"].includes(sev);
                    if (filters.severity === 'info') return ["info", "ok", "normal"].includes(sev);
                    return sev.includes(filters.severity);
                })();

                // Note: s.type holds the 'agent_type' from backend
                const matchesType = !filters.type || (s.type && s.type.toLowerCase().includes(filters.type));

                const matchesBlockId = !filters.block_id || 
                                     (s.frontend_block_id && normalizeFrontendBlockId(s.frontend_block_id) === filters.block_id) ||
                                     (s.group_id && s.group_id === filters.block_id);

                return (
                    (!filters.device_name || (s.device_name && s.device_name.toLowerCase().includes(filters.device_name))) &&
                    matchesSeverity &&
                    matchesType && // Use matchesType from above
                    (!filters.group_name || (s.group_name && s.group_name.toLowerCase().includes(filters.group_name))) &&
                    (!filters.message || (s.message && s.message.toLowerCase().includes(filters.message))) &&
                    (!fromTime || timestamp >= fromTime) &&
                    (!toTime || timestamp <= toTime) &&
                    matchesBlockId
                );
            });
            currentPage = 1;
            renderTable(filteredData);
            renderSummaryCards(filteredData);
        }

        /**
         * Clears all filter inputs and reloads the table with fresh data.
         */
        function clearFilters() {
            document.getElementById('device_name').value = '';
            document.getElementById('severity').value = '';
            document.getElementById('type').value = '';
            document.getElementById('group_name').value = '';
            document.getElementById('message').value = '';
            document.getElementById('block_id_filter').value = ''; // Clear block ID filter
            document.getElementById('block_id_filter').disabled = true; // Disable it again
            setDefaultTimeFilters(); // Reset time filters to default (last 12 hours)
            currentPage = 1;
            fetchData(); // Fetch fresh data with no filters (other than default time range)
        }

        /**
         * Populates the datalists for filter inputs with unique values from the data.
         * @param {Array<Object>} data - The raw alarm data.
         */
        function populateFilters(data) {
            const sets = {
                device_names: new Set(),
                severities: new Set(),
                types: new Set(), // Now for 'agent_type'
                group_names: new Set()
            };

            data.forEach(hit => {
                const s = hit._source;
                if (s.device_name) sets.device_names.add(s.device_name);
                if (s.severity) sets.severities.add(s.severity);
                if (s.type) sets.types.add(s.type); // Populate 'types' datalist from 'type' field (agent_type)
                if (s.group_name) sets.group_names.add(s.group_name);
            });

            for (let key in sets) {
                const datalist = document.getElementById(key);
                datalist.innerHTML = ''; // Clear existing options
                [...sets[key]].sort().forEach(v => {
                    const option = document.createElement('option');
                    option.value = v;
                    datalist.appendChild(option);
                });
            }
        }

        /**
         * Renders the alarm data into the table, applying pagination.
         * Applies severity-based row styling and handles empty data.
         * @param {Array<Object>} data - The alarm data (can be allData or filteredData) to render.
         */
        function renderTable(data) {
            const tbody = document.querySelector("#results tbody");
            const totalAlarms = data.length;
            const startIndex = (currentPage - 1) * alarmsPerPage;
            const endIndex = startIndex + alarmsPerPage;
            const paginatedData = data.slice(startIndex, endIndex);

            if (paginatedData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center py-4 text-gray-500">No alarms found matching your criteria.</td></tr>';
            } else {
                tbody.innerHTML = paginatedData.map(hit => {
                    const s = hit._source;
                    const sev = (s.severity || '').toLowerCase();
                    let rowClass = 'severity-Info'; // Default to light blue for others
                    if (["critical", "error", "fatal"].includes(sev)) {
                        rowClass = 'severity-Critical'; // Light red
                    } else if (["warning", "major", "minor"].includes(sev)) {
                        rowClass = 'severity-Warning'; // Light yellow
                    }

                    function safe(value) {
                        return value === null || value === undefined ? '' : value;
                    }
                    
                    // Use a more descriptive device name if available
                    const deviceDisplayName = (s.channel_name && s.channel_name !== 'N/A' && s.device_name && s.device_name !== 'N/A')
                                                ? `${safe(s.channel_name)} - ${safe(s.device_name)}`
                                                : safe(s.device_name) || safe(s.device_ip) || 'N/A';

                    return `<tr class="${rowClass} hover:bg-gray-50 transition duration-150 ease-in-out">
                        <td data-label="Timestamp">${safe(new Date(s.timestamp).toLocaleString())}</td>
                        <td data-label="Device Name">${deviceDisplayName}</td>
                        <td data-label="Type">${safe(s.type)}</td>
                        <td data-label="Device IP">${safe(s.device_ip)}</td>
                        <td data-label="Group Name">${safe(s.group_name)}</td>
                        <td data-label="Message">${safe(s.message)}</td>
                        <td data-label="Severity">${safe(s.severity)}</td>
                        <td data-label="Block ID" style="display: none;">${safe(s.frontend_block_id || s.group_id)}</td> <!-- Hiding the data cell -->
                    </tr>`;
                }).join('');
            }
            renderPaginationControls(totalAlarms);
        }

        /**
         * Renders the pagination controls (Previous, Next, and page numbers).
         * @param {number} totalAlarms - The total number of alarms in the current filtered dataset.
         */
        function renderPaginationControls(totalAlarms) {
            const paginationContainer = document.getElementById('pagination-controls');
            const totalPages = Math.ceil(totalAlarms / alarmsPerPage);
            paginationContainer.innerHTML = '';

            if (totalPages <= 1) {
                return; // No pagination needed for 1 or fewer pages
            }

            const prevButton = document.createElement('button');
            prevButton.textContent = 'Previous';
            prevButton.disabled = currentPage === 1;
            prevButton.onclick = () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderTable(filteredData);
                }
            };
            paginationContainer.appendChild(prevButton);

            const pageSpan = document.createElement('span');
            pageSpan.textContent = `Page ${currentPage} of ${totalPages}`;
            paginationContainer.appendChild(pageSpan);

            const nextButton = document.createElement('button');
            nextButton.textContent = 'Next';
            nextButton.disabled = currentPage === totalPages;
            nextButton.onclick = () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderTable(filteredData);
                }
            };
            paginationContainer.appendChild(nextButton);

            // Optional: Add direct page number buttons for more pages
            if (totalPages > 5) { // Show only a few page numbers if many pages
                const startPage = Math.max(1, currentPage - 2);
                const endPage = Math.min(totalPages, currentPage + 2);

                if (startPage > 1) {
                    const ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    paginationContainer.insertBefore(ellipsis, nextButton);
                }

                for (let i = startPage; i <= endPage; i++) {
                    const pageNumButton = document.createElement('button');
                    pageNumButton.textContent = i;
                    pageNumButton.classList.add('page-number');
                    if (i === currentPage) {
                        pageNumButton.classList.add('active');
                    }
                    pageNumButton.onclick = () => {
                        currentPage = i;
                        renderTable(filteredData);
                    };
                    paginationContainer.insertBefore(pageNumButton, nextButton);
                }
                if (endPage < totalPages) {
                    const ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    paginationContainer.insertBefore(ellipsis, nextButton);
                }

            } else { // Show all page numbers if few pages
                for (let i = 1; i <= totalPages; i++) {
                    const pageNumButton = document.createElement('button');
                    pageNumButton.textContent = i;
                    pageNumButton.classList.add('page-number');
                    if (i === currentPage) {
                        pageNumButton.classList.add('active');
                    }
                    pageNumButton.onclick = () => {
                        currentPage = i;
                        renderTable(filteredData);
                    }
                    paginationContainer.insertBefore(pageNumButton, nextButton);
                }
            }
        }


        /**
         * Displays a user-friendly message in a modal-like fashion (instead of alert).
         * @param {string} message - The message to display.
         */
        function showUserMessage(message) {
            let messageBox = document.getElementById('user-message-box');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'user-message-box';
                messageBox.className = 'fixed top-4 right-4 bg-red-500 text-white px-4 py-3 rounded-lg shadow-lg flex items-center space-x-2 z-50';
                messageBox.innerHTML = `
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span id="user-message-text"></span>
                    <button onclick="this.parentNode.remove()" class="ml-auto text-white hover:text-gray-200">
                        <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                `;
                document.body.appendChild(messageBox);
            }
            document.getElementById('user-message-text').textContent = message;
            messageBox.style.display = 'flex';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }

        // Initial setup for default time filters before fetching data
        document.addEventListener('DOMContentLoaded', setDefaultTimeFilters);
        // Initial data fetch when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const queryParams = getQueryParams();
            const blockIdFromUrl = queryParams.block_id;

            if (blockIdFromUrl) {
                document.getElementById('block_id_filter').value = blockIdFromUrl;
                document.getElementById('block_id_filter').disabled = false; // Enable it so its value is included in fetchBody
                // When coming from dashboard, immediately apply the block_id filter
                fetchData(true, blockIdFromUrl); // Pass true to gather all filters, and blockIdFromUrl
            } else {
                fetchData(); // Initial fetch without specific block_id filter
            }
            // Auto-refresh also applies block_id filter if it exists
            autoRefreshInterval = setInterval(() => {
                const currentBlockId = document.getElementById('block_id_filter').value;
                const isBlockIdActive = currentBlockId !== '' && !document.getElementById('block_id_filter').disabled;
                fetchData(isBlockIdActive, isBlockIdActive ? currentBlockId : null);
            }, REFRESH_INTERVAL_MS);
        });
    </script>
</body>
</html>
